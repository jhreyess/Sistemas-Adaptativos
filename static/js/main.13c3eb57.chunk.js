(this.webpackJsonpghpages=this.webpackJsonpghpages||[]).push([[0],{265:function(e,t,a){"use strict";a.r(t);var i=a(1),s=a.n(i),n=a(21),r=a.n(n),o=a(8),c=a(2),h=(a(33),a(28)),d=(a(34),a(0));var l=function(){var e=Object(i.useState)(window.matchMedia("(min-width: 768px)").matches),t=Object(h.a)(e,2),a=t[0],s=t[1];Object(i.useEffect)((function(){window.matchMedia("(min-width: 768px)").addListener((function(e){return s(e.matches)}))}),[]);var n=function(){a||document.getElementById("burgerIcon").classList.toggle("active");var e=document.getElementById("navbarLinks");e.classList.toggle("open"),e.classList.toggle("close")},r=a?null:Object(d.jsx)(i.Fragment,{children:Object(d.jsx)("div",{className:"navbarBanner",children:Object(d.jsxs)("div",{className:"burgerIcon",id:"burgerIcon",onClick:n,children:[Object(d.jsx)("div",{className:"burgerLine"}),Object(d.jsx)("div",{className:"burgerLine"}),Object(d.jsx)("div",{className:"burgerLine"})]})})});return Object(d.jsxs)("nav",{className:"navbar",children:[r,Object(d.jsxs)("div",{className:"navbarLinks close",id:"navbarLinks",children:[Object(d.jsx)(o.b,{to:"/practica1",activeClassName:"active",onClick:n,children:"Practica 1"}),Object(d.jsx)(o.b,{to:"/practica2",activeClassName:"active",onClick:n,children:"Practica 2"}),Object(d.jsx)(o.b,{to:"/practica3",activeClassName:"active",onClick:n,children:"Practica 3"}),Object(d.jsx)(o.b,{to:"/practica4",activeClassName:"active",onClick:n,children:"Practica 4"}),Object(d.jsx)(o.b,{to:"/pia",activeClassName:"active",onClick:n,children:"PIA"})]})]})},j=a(267),b=a(266);a(41);var f=function(e){return Object(d.jsx)("div",{className:"sidebarWrapper",children:Object(d.jsx)("nav",{className:"sidebar",children:e.children})})};a(42);var p=function(e){return Object(d.jsx)("article",{className:"section",children:e.children})};a(43);var m=function(e){return Object(d.jsx)("div",{className:"imgWrapper",children:e.children})};a(44);var u=function(e){return Object(d.jsx)("div",{className:"table",children:Object(d.jsx)("table",{children:e.children})})};a(45);var A=function(e){return Object(d.jsx)("div",{className:"legend",children:Object(d.jsx)("span",{children:e.children})})},g=a.p+"static/media/roads.4c91e9c8.jpg",x=a.p+"static/media/cases.67fb771b.jpg",w=a.p+"static/media/graph.69f3fb79.jpg",v=a.p+"static/media/equation1.7375545f.jpg",O=a.p+"static/media/queue.322f7b35.jpg";var y=function(){return Object(d.jsxs)("div",{className:"content",children:[Object(d.jsxs)(f,{children:[Object(d.jsx)("a",{href:"#practica1/description",children:"Description"}),Object(d.jsx)("a",{href:"#practica1/objectives",children:"Objectives"}),Object(d.jsx)("a",{href:"#practica1/introduction",children:"Introduction"}),Object(d.jsx)("a",{href:"#practica1/design",children:"Design"}),Object(d.jsx)("a",{href:"#practica1/code",children:"Code"}),Object(d.jsx)("a",{href:"#practica1/video",children:"Performance"}),Object(d.jsx)("a",{href:"#practica1/conclusions",children:"Conclusions"}),Object(d.jsx)("a",{href:"#practica1/references",children:"References"})]}),Object(d.jsxs)(p,{children:[Object(d.jsx)("h1",{children:"Adaptive Algorithm"}),Object(d.jsx)("hr",{}),Object(d.jsx)("h3",{id:"practica1/description",children:"Description"}),Object(d.jsx)("p",{children:"In this activity it will be implemented a system that simulates congested streets and it adjust automatically the duration of the green traffic lights on the streets."}),Object(d.jsx)("h3",{id:"practica1/objectives",children:"Objectives"}),Object(d.jsxs)("ul",{children:[Object(d.jsx)("li",{children:"Implement Traffic light control in an environment of intersections and avenues of various senses"}),Object(d.jsx)("li",{children:"Make a report where you can describe your work and the results you got"})]}),Object(d.jsx)("h3",{id:"practica1/introduction",children:"Introduction"}),Object(d.jsx)("p",{children:"The problem was solved using Python and different modules such as Pygame for the simulation displaying and threading for the execution of the algorithm. The first task done was to create the environment of intersections and congested streets, after that, it was necessary to consider the different ways how adjustment could be solved, in this case, the analysis of the street lanes senses allows us to determine the quantity of queues and servers that the system have. Later in this document, it will be possible to observe the development of a MVC architecture implementing queues and threads."}),Object(d.jsx)("h3",{id:"practica1/design",children:"Cross Street Design & Graphic Scheme "}),Object(d.jsxs)("p",{children:["In the diagram below, the different directions of the street lanes are shown, in which it is possible to see the straight direction and the turn direction.",Object(d.jsx)("br",{}),"A symbology is attached to each lane to allow understanding of the problem."]}),Object(d.jsxs)(m,{children:[Object(d.jsx)("img",{src:g,alt:"Roads"}),Object(d.jsx)("img",{src:x,alt:"Graph"})]}),Object(d.jsx)("h3",{children:"Conflict matrix"}),Object(d.jsxs)(u,{children:[Object(d.jsx)("thead",{children:Object(d.jsxs)("tr",{className:"table-row-header",children:[Object(d.jsx)("th",{}),Object(d.jsx)("th",{children:"A1"}),Object(d.jsx)("th",{children:"A2"}),Object(d.jsx)("th",{children:"B1"}),Object(d.jsx)("th",{children:"B2"}),Object(d.jsx)("th",{children:"C1"}),Object(d.jsx)("th",{children:"C2"}),Object(d.jsx)("th",{children:"D1"}),Object(d.jsx)("th",{children:"D2"})]})}),Object(d.jsxs)("tbody",{children:[Object(d.jsxs)("tr",{className:"table-row",children:[Object(d.jsx)("td",{children:"Case 1"}),Object(d.jsx)("td",{children:"1"}),Object(d.jsx)("td",{children:"0"}),Object(d.jsx)("td",{children:"0"}),Object(d.jsx)("td",{children:"0"}),Object(d.jsx)("td",{children:"1"}),Object(d.jsx)("td",{children:"0"}),Object(d.jsx)("td",{children:"0"}),Object(d.jsx)("td",{children:"0"})]}),Object(d.jsxs)("tr",{className:"table-row",children:[Object(d.jsx)("td",{children:"Case 2"}),Object(d.jsx)("td",{children:"0"}),Object(d.jsx)("td",{children:"1"}),Object(d.jsx)("td",{children:"0"}),Object(d.jsx)("td",{children:"0"}),Object(d.jsx)("td",{children:"0"}),Object(d.jsx)("td",{children:"1"}),Object(d.jsx)("td",{children:"0"}),Object(d.jsx)("td",{children:"0"})]}),Object(d.jsxs)("tr",{className:"table-row",children:[Object(d.jsx)("td",{children:"Case 3"}),Object(d.jsx)("td",{children:"0"}),Object(d.jsx)("td",{children:"0"}),Object(d.jsx)("td",{children:"1"}),Object(d.jsx)("td",{children:"0"}),Object(d.jsx)("td",{children:"0"}),Object(d.jsx)("td",{children:"0"}),Object(d.jsx)("td",{children:"1"}),Object(d.jsx)("td",{children:"0"})]}),Object(d.jsxs)("tr",{className:"table-row",children:[Object(d.jsx)("td",{children:"Case 4"}),Object(d.jsx)("td",{children:"0"}),Object(d.jsx)("td",{children:"0"}),Object(d.jsx)("td",{children:"0"}),Object(d.jsx)("td",{children:"1"}),Object(d.jsx)("td",{children:"0"}),Object(d.jsx)("td",{children:"0"}),Object(d.jsx)("td",{children:"0"}),Object(d.jsx)("td",{children:"1"})]})]})]}),Object(d.jsx)("h3",{children:"Solution Design"}),Object(d.jsx)("p",{children:"The first thing done was the separation of cases graphicly, in the image below it's possible to see the four cases and the street lanes that they integrate."}),Object(d.jsx)(m,{children:Object(d.jsx)("img",{src:w,alt:"Road cases"})}),Object(d.jsx)("p",{children:"Subsequently it was necessary a mecanism to determine how many servers and queues the system would have and the service mechanism to be implemented. The next image represents the queue system that will be implemented. The input source has infinite size, this is because the cars will arrive randomly, and their arrival times are probabilistic. In this case the queue capacity is considered finite. The service discipline is a FIFO structure where the cars of one queue are catered while the other one is waiting. The time of service will be given by the traffic light considering the number of cars in each street lane at its service and given by the following equation."}),Object(d.jsx)(m,{children:Object(d.jsx)("img",{src:v,alt:"Equation (1)"})}),Object(d.jsx)(A,{children:"Where 'n' is the number of cars in the queue, 't' stands for the pedestrian crossing time and 'm' is the maximum number of cars that can be in the queue."}),Object(d.jsx)("p",{children:"In the straight lanes, base time never goes under t, this allows to pedestrians to have a reference of the minimum time to cross the street, in this case 't' seconds. The green light assignation is a variable between the straight roads and the turn roads, because while the cars of the turn roads are moving, the pedestrian can\xb4t cross, so in the X2 and Y2 roads the time is given by an arithmetic operation and in the X1 and Y1 roads the value of the operation is added to 5."}),Object(d.jsx)("p",{children:"The served clients are those cars that have already left behind the traffic light."}),Object(d.jsx)(m,{children:Object(d.jsx)("img",{src:O,alt:"Queues"})}),Object(d.jsx)("h3",{id:"practica1/code",children:"Code"}),Object(d.jsx)("p",{children:"In the programming stage the problem was to find a correct way to make the system, implementing tools such as threads. The solution was obtained through the analysis of each member of the team. The general idea is raised grouping the street lanes by pairs, each pair was named by its position, (vertical = Y, horizontal = X), and by its direction (straight = 1, turn = 2), getting four groups described in the next list: "}),Object(d.jsxs)("ul",{children:[Object(d.jsx)("li",{children:"roadsX1 : A1 C1"}),Object(d.jsx)("li",{children:"roadsX2 : A2 C2"}),Object(d.jsx)("li",{children:"roadsY1 : B1 D1"}),Object(d.jsx)("li",{children:"roadsY2 : B2 D2"})]}),Object(d.jsxs)("p",{children:["The first time of the green light was defined by the number of cars in the street lanes having a self adjustment that allows a better vehicular flow.",Object(d.jsx)("br",{}),"The movement of the cars was done by the following function."]}),Object(d.jsx)("div",{className:"coding",children:Object(d.jsx)(j.a,{language:"python",style:b.a,wrapLongLines:!0,children:"\n    def move(self, isGreen):\n        self.canMove = self.calculateDistance(self.stopPlace)\n        self.isRoadClear = self.calculateCarDistance()\n        if((self.isRoadClear and self.canMove) or isGreen):\n            if self.isVertical:\n                self.posY -= self.sign*self.carSpeed\n            else:\n                self.posX -= self.sign*self.carSpeed\n            if((self.posX < -400) or (self.posX > 1040) or (self.posY > 1040) or (self.posY < -400)):\n                self.newCoords()\n    "})}),Object(d.jsx)("p",{children:"The different states of each traffic light are given by the next code:"}),Object(d.jsx)("div",{className:"coding",children:Object(d.jsx)(j.a,{language:"python",style:b.a,wrapLongLines:!0,children:"\n    def init(self):\n        while True:\n            if(self.state==1):\n                self.roadsX1.setState(True) # Turn Green\n                time = self.roadsX1.getTime()*(self.cross_time/self.maxCars) + self.cross_time\n                sleep(time)\n                self.roadsX1.setState(False) # Turn Red\n\n            elif(self.state==2):\n                self.roadsX2.setState(True) # Turn Green\n                time = self.roadsX2.getTime()*(self.cross_time/self.maxCars)\n                sleep(time)\n                self.roadsX2.setState(False) # Turn Red\n\n            elif(self.state==3):\n                self.roadsY1.setState(True) # Turn Green\n                time = self.roadsY1.getTime()*(self.cross_time/self.maxCars) + self.cross_time\n                sleep(time)\n                self.roadsY1.setState(False) # Turn Red\n\n            elif(self.state==4):\n                self.roadsY2.setState(True) # Turn Green\n                time = self.roadsY2.getTime()*(self.cross_time/self.maxCars)\n                sleep(time)\n                self.roadsY2.setState(False) # Turn Red\n                self.state = 0\n            \n            self.state += 1\n            if self.stop_threads:\n                self.roadsX1.stop()\n                self.roadsX2.stop()\n                self.roadsY1.stop()\n                self.roadsY1.stop()\n    "})}),Object(d.jsx)("p",{children:"And the final time is obtained by the comparation between street lanes of each group of road, this because there are 2 servers, one for each axis (X and Y) and the time in which the cars advance is the opposite. (X1,Y1) and (X2,Y2)"}),Object(d.jsx)("div",{className:"coding",children:Object(d.jsx)(j.a,{language:"python",style:b.a,wrapLongLines:!0,children:"\n    def getTime(self):\n        time1 = self.trafficLight1.getCrossTime()\n        time2 = self.trafficLight2.getCrossTime()\n        return time1 if time1 > time2 else time2\n    "})}),Object(d.jsx)("p",{children:"The code in the main view file is the following:"}),Object(d.jsx)("div",{className:"coding",children:Object(d.jsx)(j.a,{language:"python",style:b.a,wrapLongLines:!0,children:"\n    import sys, pygame\n    import threading\n    from controller.roads import Roads\n\n    pygame.init()\n\n    # Screen settings\n    scale = {'width': 640, 'height': 640}\n    screen = pygame.display.set_mode((scale['width'], scale['height']))\n    pygame.display.set_caption(\"Traffic Lights\")\n    clock = pygame.time.Clock()\n\n    roads = Roads(screen)\n    roads_thread = threading.Thread(target=roads.init, name=\"Roads thread\").start()\n\n    while True:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                roads.stop_threads = True\n                pygame.quit()\n                sys.exit()\n        \n        roads.show()\n        roads.update()\n\n        clock.tick(60)\n    "})}),Object(d.jsx)("h3",{id:"practica1/video",children:"Performance"}),Object(d.jsx)("iframe",{src:"https://www.youtube.com/embed/epZEQi-c4bI",title:"YouTube video player",frameBorder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowFullScreen:!0}),Object(d.jsx)("h3",{id:"practica1/conclusions",children:"Conclusion"}),Object(d.jsx)("p",{children:"This activity was a total challenge for the teamwork, before reading the theory that involves an auto adjust system the ideas that each member had were too different to the final product. The correct analysis of the problem considering all the factors that can influence the output was very important, in this case it was necessary to see some videos about the topic and read some web pages about how an auto adjust system works, including theory about queues, threads, modular programming and the MVC architecture. Working with Python was simple because the implementation of its module named Pygame allows a better manipulation of the graphic interface and his components than other programming languages. The main problem was to create some threads that allow the execution of the different parts of the system such as queues (of cars) and servers (traffic lights), but it was solved with the structure mentioned before, the other problem was to implement the auto adjust, this considering the number of cars of the road that will advance and the time for the people that will cross the streets, this also was solved with the support of all the teamwork making a process based on an arithmetic operation. The problems made each member to think about a solution and give the idea to all the other members so with this the construction of this auto adjust system the team could reach the objectives and have a great solution of the traffic light control. To finalize, some improves that would be implemented are the substitution of the figures that make up the car for an image that represent better the concept, the same for the traffic lights, the last thing that would change is the duration of the green light for a more realistic, in this case the velocity of the cars must change."}),Object(d.jsx)("h3",{id:"practica1/references",children:"References"}),Object(d.jsxs)("ol",{children:[Object(d.jsxs)("li",{children:["3.9.7 Documentation. (n.d.). Python. Retrieved September 20, 2021, from ",Object(d.jsx)("a",{href:"https://docs.python.org/3/",children:"python.org"})]}),Object(d.jsxs)("li",{children:["Pygame Front Page - pygame v2.0.1. documentation. (n.d.). Retrieved September 20, 2021, from ",Object(d.jsx)("a",{href:"https://www.pygame.org/docs",children:"pygame.org"})]}),Object(d.jsxs)("li",{children:["Python threading tutorial: Run Code Concurrently Using the Threading Module. (2019) ",Object(d.jsx)("a",{href:"https://www.youtube.com/watch?v=IEEhzQoKtQU",children:"Youtube"})]}),Object(d.jsxs)("li",{children:["Svirca, Z. (2020, May 30). Everything you need to know about MVC architecture - Towards Data Science. Medium ",Object(d.jsx)("a",{href:"https://towardsdatascience.com/everything-you-need-to-know-about-mvc-architecture-3c827930b4c1#:%7E:text=%2DMVC%20is%20an%20architectural%20pattern,is%20invented%20",children:"Towards Data Science"})]}),Object(d.jsxs)("li",{children:["Teor\xeda de Colas Conceptos b\xe1sicos. (2012, March, 23). ",Object(d.jsx)("a",{href:"https://www.youtube.com/watch?v=jb3_zvj0w_c",children:"Youtube"})]})]})]})]})},F=a.p+"static/media/network.3e821861.jpg",U=a.p+"static/media/file.8db2a1e4.jpg",N=a.p+"static/media/file2.5c36166a.jpg",B=a.p+"static/media/code1.47ca86fd.jpg",S=a.p+"static/media/diapo1.0b57f82c.jpg",T=a.p+"static/media/diapo2.d25fa8a7.jpg",K=a.p+"static/media/diapo3.0a05b849.jpg",R=a.p+"static/media/diapo4.f587246a.jpg",L=a.p+"static/media/diapo5.559e5f2b.jpg",C=a.p+"static/media/diapo6.aaa6a862.jpg",D=a.p+"static/media/diapo7.b1dea59a.jpg",Q=a.p+"static/media/diapo8.e3662c8e.jpg",E=a.p+"static/media/diapo9.1f17ee44.jpg",P=a.p+"static/media/diapo10.f2275b3a.jpg",k=a.p+"static/media/diapo11.07792fc1.jpg",X=a.p+"static/media/diapo12.df8cabcb.jpg";var I=function(){return Object(d.jsxs)("div",{className:"content",children:[Object(d.jsxs)(f,{children:[Object(d.jsx)("a",{href:"#practica2/networks",children:"Complex Networks"}),Object(d.jsx)("a",{href:"#practica2/solution",children:"Coding"}),Object(d.jsx)("a",{href:"#practica2/video",children:"Performance"}),Object(d.jsx)("a",{href:"#practica2/chaos",children:"Fractal Art"}),Object(d.jsx)("a",{href:"#practica2/conclusions",children:"Conclusions"}),Object(d.jsx)("a",{href:"#practica2/references",children:"References"})]}),Object(d.jsxs)(p,{children:[Object(d.jsx)("h1",{children:"Complex Systems"}),Object(d.jsx)("hr",{}),Object(d.jsx)("h3",{id:"practica2/networks",children:"Complex Networks"}),Object(d.jsxs)("p",{children:["Do the following exercises",Object(d.jsxs)("ol",{children:[Object(d.jsx)("li",{children:"Draw a graph that represents a small part of your network of friends"}),Object(d.jsx)("li",{children:"Save the adjacency matrix for this graph to a file. The file must be able to be read by a program"})]})]}),Object(d.jsx)(m,{children:Object(d.jsx)("img",{src:F,alt:"Network"})}),Object(d.jsx)(m,{children:Object(d.jsx)("img",{src:U,alt:"Network"})}),Object(d.jsx)("h3",{id:"practica2/solution",children:"Solution"}),Object(d.jsxs)("p",{children:["The code was made in Java. In general, there are three classes that made the system work. The Node class is the class made for each Node of the graph, it has some attributes such as vertex order and an array that contains its adjacencies.",Object(d.jsx)("br",{}),Object(d.jsx)("br",{}),"GraphReader is the class that allows the file to be read, and it also sets the number of nodes, edges and the vertex orders, it can aslo print the matrix.",Object(d.jsx)("br",{}),Object(d.jsx)("br",{}),"Main class is where the other classes are called in order to run the code and get the desired results from reading the matrix."]}),Object(d.jsx)(j.a,{language:"java",style:b.a,wrapLongLines:!0,children:' // GraphReader Class\npublic class GraphReader{\n\n    ArrayList<Node> graph = new ArrayList<>();\n    int numberOfEdges = 0;\n\n    public GraphReader(String fileName){\n        String filepath = new File("").getAbsolutePath() + "/../resources/"+fileName;\n        startReading(filepath);\n    }\n}\n'}),Object(d.jsx)(j.a,{language:"java",style:b.a,wrapLongLines:!0,children:'public class Main{\n    public static void main(String[] args){\n        System.out.println("Hello World!");\n        String fileName = "matrizAdyacencias.txt";\n        GraphReader graph = new GraphReader(fileName);\n        graph.print();\n        System.out.println("Vertexes: "+graph.getNumberOfNodes());\n        System.out.println("Edges: "+graph.getNumberOfEdges());\n        System.out.println("Vertex 1 order: "+graph.getVertexOrder(1));\n        System.out.println("Vertex 2 order: "+graph.getVertexOrder(2));\n        System.out.println("Vertex 3 order: "+graph.getVertexOrder(3));\n        System.out.println("Vertex 4 order: "+graph.getVertexOrder(4));\n        System.out.println("Vertex 5 order: "+graph.getVertexOrder(5));\n    }\n}\n'}),Object(d.jsx)(j.a,{language:"java",style:b.a,wrapLongLines:!0,children:"public class Node{\n    int vertex_order = 0;\n    ArrayList<Integer> adjacency = new ArrayList<>();\n\n    public void add(int number){\n        adjacency.add(number);\n        vertex_order += number == 1 ? 1 : 0;\n    }\n\n    public ArrayList<Integer> getAdjacency(){ return adjacency; }\n    public int getVertex_order(){ return vertex_order; }\n}"}),Object(d.jsxs)("p",{children:["Calculate the values of n (number of vertices), m (number of edges) and degree of each of the vertices. Consider that your matrix is symmetric.",Object(d.jsx)("br",{}),Object(d.jsx)("br",{}),"The calculation of the number of vertices, and vertex order and the number of edges is also done by the startReading method from the GraphReader class."]}),Object(d.jsx)(j.a,{language:"java",style:b.a,wrapLongLines:!0,children:"public void startReading(String filepath){\n    try{\n        Scanner file_scan = new Scanner(new File(filepath));\n        while(file_scan.hasNextLine()){\n            Scanner nextLine = new Scanner(file_scan.nextLine());\n            Node node = new Node();\n            while(nextLine.hasNextInt()){\n                node.add(nextLine.nextInt());\n            }\n            graph.add(node);\n        }\n        for(Node node: graph){\n            numberOfEdges += node.getVertex_order();\n        }\n        numberOfEdges /= 2;\n    }catch(FileNotFoundException e){\n        e.printStackTrace();\n    }\n}\n"}),Object(d.jsx)("p",{children:"The vertex order sample is done by the getVertexOrder method from GraphReader class and called in the Main Class."}),Object(d.jsx)(j.a,{language:"java",style:b.a,wrapLongLines:!0,children:'public int getVertexOrder(int vertex){\n    boolean inBounds = (vertex > 0) && (vertex <= graph.size());\n    if(inBounds){\n        return graph.get(vertex-1).getVertex_order();\n    }else{\n        System.out.println("Undefined vertex");\n        return 0;\n    }\n}'}),Object(d.jsx)("p",{children:"By introducing as input the file shown below, the following results were obtained"}),Object(d.jsxs)(m,{children:[Object(d.jsx)("img",{src:N,alt:"File"}),Object(d.jsx)("img",{src:B,alt:"Code Results"})]}),Object(d.jsx)("h3",{id:"practica2/video",children:"Performance"}),Object(d.jsx)("iframe",{src:"https://www.youtube.com/embed/MaiD8eFvmnM",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0}),Object(d.jsx)("h3",{id:"practica2/chaos",children:"Chaos: Fractal Art - Part One"}),Object(d.jsxs)(m,{children:[Object(d.jsx)("img",{src:S,alt:"Slide 1"}),Object(d.jsx)("img",{src:T,alt:"Slide 2"})]}),Object(d.jsxs)(m,{children:[Object(d.jsx)("img",{src:K,alt:"Slide 3"}),Object(d.jsx)("img",{src:R,alt:"Slide 4"})]}),Object(d.jsx)(m,{children:Object(d.jsx)("img",{src:L,alt:"Slide 5"})}),Object(d.jsx)("h3",{id:"practica2/chaos-2",children:"Chaos: Fractal Art - Part Two"}),Object(d.jsxs)(m,{children:[Object(d.jsx)("img",{src:D,alt:"Slide 7"}),Object(d.jsx)("img",{src:Q,alt:"Slide 8"})]}),Object(d.jsxs)(m,{children:[Object(d.jsx)("img",{src:E,alt:"Slide 9"}),Object(d.jsx)("img",{src:P,alt:"Slide 10"})]}),Object(d.jsx)(m,{children:Object(d.jsx)("img",{src:k,alt:"Slide 11"})}),Object(d.jsx)("h3",{id:"practica2/conclusions",children:"Conclusion"}),Object(d.jsx)("p",{children:"While doing this activity the information about graph characteristics was useful because some members of the teams didn't knew what an edge nor node was, it was necessary to read something about graphs to be able to move on to the next part, the code, it was decided to use Java as the programming language, its paradigm allow us to work with three different classes and with this obtain the results. The structure was simple, a class for the reader, the node and a main class that could execute the code, the calculation of the edges, vertices, and the vertex degree was simple thanks to the teamwork and the information read. The second part that talks about fractal art was so interesting because no one of us knew about this and doing the research was incredible. We were able to know a little more about what fractal art is and how we could code it."}),Object(d.jsx)("h3",{id:"practica2/references",children:"References"}),Object(d.jsxs)(m,{children:[Object(d.jsx)("img",{src:C,alt:"slide6"}),Object(d.jsx)("img",{src:X,alt:"slide12"})]})]})]})},V=a.p+"static/media/example1.6c0f0878.jpg",H=a.p+"static/media/example2.de0e9466.jpg",M=a.p+"static/media/example3.4a15dc0c.jpg";var G=function(){return Object(d.jsxs)("div",{className:"content",children:[Object(d.jsxs)(f,{children:[Object(d.jsx)("a",{href:"#practica3/introduction",children:"Introduction"}),Object(d.jsx)("a",{href:"#practica3/objective",children:"Objective"}),Object(d.jsx)("a",{href:"#practica3/theory",children:"Theoretical Framework"}),Object(d.jsx)("a",{href:"#practica3/dev",children:"Development"}),Object(d.jsx)("a",{href:"#practica3/code",children:"Coding"}),Object(d.jsx)("a",{href:"#practica3/video",children:"Performance"}),Object(d.jsx)("a",{href:"#practica3/conclusions",children:"Conclusions"}),Object(d.jsx)("a",{href:"#practica3/references",children:"References"})]}),Object(d.jsxs)(p,{children:[Object(d.jsx)("h1",{children:"Greedy Best-First Search"}),Object(d.jsx)("hr",{}),Object(d.jsx)("h3",{id:"practica3/introduction",children:"Introduction"}),Object(d.jsxs)("p",{children:["Greedy Best-First Search is one of the available topics to use for working on this practice, it is an algorithm used to find the shortest path to reach a goal, it needs contextual information to work.",Object(d.jsx)("br",{}),Object(d.jsx)("br",{}),"GBFS is part of search algorithms, this kind of algorithms is used in many areas like route and cost optimizations, action planning, knowledge, mining, robotics, autonomous driving cars, computational biology, software, etc..."]}),Object(d.jsx)("h3",{id:"practica3/objective",children:"Objective"}),Object(d.jsx)("p",{children:"It is possible to demonstrate the functionality of this algorithm by a puzzle, which consists in a sets of numbers inside a square, there is a gap that allows to move the numbers in order to achieve the correct ordering. This puzzle can be solved using search algorithms, The goal for this practice is to develop an algorithm that solves many different combinations of this puzzle."}),Object(d.jsx)("h3",{children:"Justification"}),Object(d.jsx)("p",{children:"Troubleshooting by search, specifically GBFS was chosen because it's one of the best tree search algorithms, yet is easy to implement."}),Object(d.jsx)("h3",{id:"practica3/theory",children:"Theoretical Framework"}),Object(d.jsx)("p",{children:"Greedy best-first search algorithm is part of search algorithms, this kind of algorithms are used in areas like, knowledge mining, robotics, autonomous driving, computational biology, software and hardware verification, and others. Search algorithms are models of problems where the task is to reach a goal from the initial state via state transformation rules, so the search space can be described as a graph or a three where the aim is to reach the goal from the initial state via the shortest path."}),Object(d.jsxs)("p",{children:["Search algorithms can be classified into two categories:",Object(d.jsxs)("ul",{children:[Object(d.jsx)("li",{children:"Uniformed or Exhaustive: Where the search is done only with the information given in the problem statement, in this group are Breadth First Search and Depth First Search."}),Object(d.jsx)("li",{children:"Informed or Heurisitc: Where search is done by using extra information to determine the next step to reach the goal, in this group is Greedy Best-First Search."})]})]}),Object(d.jsx)("p",{children:"The Greedy best-first search is a combination of depth-first search and breadth-first-search, but this algorithm selects the best path by using a Heurisitc function, so you can say that it is better than the others. In a general way, BFS choose the most promising node of a graph in each step, so this algorithm expands the node, whis is closest to the goal node, by using a Heurisitc function, we can determine the closest cost and with this, select the next node."}),Object(d.jsx)("h3",{children:"Example"}),Object(d.jsx)("p",{children:"It is required to generate at least 4 nodes of the graph that allows the solution of the puzzle by using GBFS. It uses a function that indicates in this case how far are you from the goal. The total distance or the value of the function is the sum of the Manhattan distance of each block to reach its state on the board."}),Object(d.jsx)("p",{children:"Function: D(T) = M(0) + M(1) + ... + M(8) "}),Object(d.jsxs)(m,{children:[Object(d.jsx)("img",{src:"data:image/jpeg;base64,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",alt:"Example"}),Object(d.jsx)("img",{src:"data:image/jpeg;base64,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",alt:"Example"})]}),Object(d.jsx)("h3",{children:"Process"}),Object(d.jsx)("p",{children:"First, it is necessary to know that by opening the first node there are only four possiblities, (up, down, left and right), the next step is to calculate the total distance of each child node, in this case by breadth-first search it is compared the value and selected the closest node to the final state, in other words, it is selected the lowest value and the node is opened."}),Object(d.jsx)(m,{children:Object(d.jsx)("img",{src:V,alt:"Example"})}),Object(d.jsx)("p",{children:"The next step is to evaluate the child nodes of the node recently opened, in this case there are only two possibilites (up and down) because the movement to the right produces a node that it is already in the opened nodes list. Again, by breadth-first search it is compared the value and selected the closest node to the final state, in this case the up node of the third level is selected and opened."}),Object(d.jsx)(m,{children:Object(d.jsx)("img",{src:H,alt:"Example"})}),Object(d.jsx)("p",{children:"Finally, for this example, the value of the only child node is calculated and compared. As the new node is the closest node to the goal, it is selected and opened."}),Object(d.jsx)(m,{children:Object(d.jsx)("img",{src:M,alt:"Example"})}),Object(d.jsx)("p",{children:"To keep advancing in the resolution of this example it is just necessary to follow the same steps until reach the goal, which is a zero value in the heuristic function. If the value of the new node is the same as the others, the first node in the graph with the same value is the best option to open."}),Object(d.jsx)("h3",{id:"practica3/dev",children:"Development"}),Object(d.jsx)("p",{children:"All the process after the initial analysis is done thanks because it is necessary to know the parameters, variations and instances before implement methods and search the goal. In this problem the firs thing to determine is the size of the impossible game, in this case the size is a 3x3 puzzle, this size was selected because is the best way to start in the resolution of more complex problems."}),Object(d.jsx)("p",{children:"To determine the initial and final state(goal) is so relevant because these are the main parameters to start searching the final node inside the graph, in this case the final state is defined in the figure number 3. The heuristic function is fundamental because it provides the value that will be compared, this value determines the best node to choose, in this case the closest node to the goal is the one with the lowest value."}),Object(d.jsx)("p",{children:"Before open the node selected, is necessary to know the possible moves based on the position of the space and avoiding creating an existing node, this to avoid redundancy. The comparison is done breadth-first search and if the value of the new node is the same as the others, the first node in the graph with the same value is the best option to open. When the value of the function is zero the goal is reached and the node is the final state."}),Object(d.jsx)("h3",{id:"practica3/code",children:"Coding"}),Object(d.jsx)("p",{children:"To code the solution of the impossible puzzle mentioned using Java the puzzle was divided in simple structures, this because the objective was to create classes for each part of the puzzle leveraging the object-oriented programming paradigm. There are three classes in the project created in this practice, they are Node, Tree and Main. Each class has attributes and methods that allows a better analysis of the problem and the code."}),Object(d.jsx)("h4",{children:"Node Class"}),Object(d.jsx)("p",{children:"This class was created to make the different nodes of the final tree, in this case, each node is a 3*3 matrix that contains an array of numbers from 0 to 8."}),Object(d.jsx)(j.a,{language:"java",style:b.a,wrapLongLines:!0,children:"\npublic class Node{\n\n    ArrayList<Integer> coords;\n    int[][] newState = new int[3][3];\n    int dt;\n    Node parentNode;\n\n    public Node(int[][] oldState, ArrayList<Integer> coords, Node parent){\n        this.coords = coords;\n        parentNode = parent;\n        for(int i=0;i<3;i++){\n            for(int j=0;j<3;j++){\n                newState[i][j] = oldState[i][j];\n            }\n        }\n        generateNewState();\n    }\n}\n"}),Object(d.jsx)("p",{children:"The generateNewState method changes the old node, that was recently selected for the new node that is closest to the goal."}),Object(d.jsx)(j.a,{language:"java",style:b.a,wrapLongLines:!0,children:"private void generateNewState(){\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            if(newState[i][j] == 0){\n                newState[i][j] = newState[coords.get(0)][coords.get(1)];\n                newState[coords.get(0)][coords.get(1)] = 0;\n            }\n        }\n    }\n    dt = calculateDt();\n}"}),Object(d.jsxs)("p",{children:["The calculateDt method calculates the value of the heuristic function by searching the position of each number in the matrix, calculating the distance from its deal position, and doing the sum.",Object(d.jsx)("br",{}),Object(d.jsx)("br",{}),"The method named searchPosition calculates the distance of each number from its ideal position and returns the value, this method makes possible to calculate the value of the heuristic function."]}),Object(d.jsx)(j.a,{language:"java",style:b.a,wrapLongLines:!0,children:"private int calculateDt(){\n    int calc = 0;\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++) {\n            calc += searchPosition(newState[i][j], i, j);\n        }\n    }\n    return calc;\n}\n\nprivate int searchPosition(int num, int posX, int posY){\n    int wantedRow = num/3;\n    int wantedCol = num%3;\n    return Math.abs(wantedRow - posX)+Math.abs(wantedCol - posY);\n}\n"}),Object(d.jsx)("h4",{children:"Tree"}),Object(d.jsx)("p",{children:"This class contains all the other methods to grow the tree, the selection of every new node, the opening of each node selected, and the algorithm that allows the efficient apply of the greedy BFS. Its constructor creates the root node and copies into o a class variable, also the node is added to the r0ute of the selection nodes, in this array are saved the nodes that were selected in its moment because they were the best node in one step."}),Object(d.jsx)(j.a,{language:"java",style:b.a,wrapLongLines:!0,children:"public class Tree{\n\n    int[][] toSolve = new int[3][3];\n    int Tvalue;\n    ArrayList<Integer> previousState;\n    ArrayList<Node> openNodes = new ArrayList<>();\n    ArrayList<Node> closedNodes = new ArrayList<>();\n    Node rootNode;\n    ArrayList<Node> path = new ArrayList<>();\n\n    public Tree(int[][] initial){\n        // Constructor copies the matrix into a \n        // variable and sets an initial State for previousState\n        for(int i=0;i<3;i++){\n            for(int j=0;j<3;j++){\n                toSolve[i][j] = initial[i][j];\n                if(toSolve[i][j] == 0){\n                    previousState = new ArrayList<>(Arrays.asList(i,j));\n                }\n            }\n        }\n        Tvalue = calculateDt(toSolve);\n        rootNode = new Node(toSolve, previousState, null);\n        closedNodes.add(rootNode); // Root Node is visited\n    }\n    ...\n"}),Object(d.jsx)("p",{children:"The calculateNodes method allows to know the possible movements based on the position of the space (in this case the space is the number zero)."}),Object(d.jsx)(j.a,{language:"java",style:b.a,wrapLongLines:!0,children:"private ArrayList<ArrayList<Integer>> calculateNodes(int[][] matrix){\n    ArrayList<ArrayList<Integer>> coords = new ArrayList<>();\n\n    //Possible movements\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            if(matrix[i][j] == 0){\n                if(i-1>=0) coords.add(new ArrayList<>(Arrays.asList(i-1,j))); //Left\n                if(i+1<3) coords.add(new ArrayList<>(Arrays.asList(i+1,j))); //Right\n                if(j-1>=0) coords.add(new ArrayList<>(Arrays.asList(i,j-1))); //Up\n                if(j+1<3) coords.add(new ArrayList<>(Arrays.asList(i,j+1))); //Down\n                break;\n            }\n        }\n    }\n\n    return coords;\n}\n"}),Object(d.jsx)("p",{children:"The method named move could be one of the most important because generates nodes and its possible states, selects the next state based on the open nodes, updates the previous state and the matrix to solve."}),Object(d.jsx)(j.a,{language:"java",style:b.a,wrapLongLines:!0,children:"private void move(){\n\n    // Generate nodes and possible states\n    ArrayList<ArrayList<Integer>> possibleMoves = calculateNodes(toSolve);\n    \n    //Remove previousState from possibleMoves\n    possibleMoves.remove(previousState);\n    for (ArrayList<Integer> possibleMove : possibleMoves) {\n        Node node = new Node(toSolve, possibleMove, rootNode);\n        if(!isVisited(node)) openNodes.add(node);\n    }\n\n    // Get next State based on open nodes\n    Node currentNode = openNodes.get(0);\n    int min = currentNode.getTvalue();\n    int[][] nextState = currentNode.getNodeState();\n    for(Node node: openNodes){\n        if(node.getTvalue() < min){\n            currentNode = node;\n            min = currentNode.getTvalue();\n            nextState = currentNode.getNodeState();\n        }\n    }\n\n    //Update Previous State\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            if(toSolve[i][j]==0) previousState = new ArrayList<>(Arrays.asList(i,j));\n        }\n    }\n\n    //Update matrix to solve\n    toSolve = nextState;\n    Tvalue = min;\n    closedNodes.add(currentNode);\n    openNodes.remove(currentNode);\n    rootNode = currentNode;\n}"}),Object(d.jsx)("p",{children:"The solve method starts the resolution of the matrix and creates a bucle that ends only when the value of the heuristic function is zero."}),Object(d.jsx)(j.a,{language:"java",style:b.a,wrapLongLines:!0,children:'public void solve(){\n    while(Tvalue > 0){ // While distance from currentState to finalState > 0\n        move(); // Execute a movement and updates Tvalue\n    }\n    while(rootNode.getParentNode() != null){\n        path.add(0, rootNode);\n        rootNode = rootNode.parentNode;\n    }\n    for(Node node: path){ node.printNewState(); }\n    System.out.println("Number of moves: "+path.size());\n    System.out.print("Finished!");\n}'}),Object(d.jsx)("h4",{children:"Main Class"}),Object(d.jsx)("p",{children:"This class allows the run of all the code, the instance of the Tree class is created and as parameter is given a 3*3 matrix that could be changed in every moment."}),Object(d.jsx)(j.a,{language:"java",style:b.a,wrapLongLines:!0,children:'public static void main(String[] args){\n    int[][] toSolve = { {4, 6, 2},\n                        {3, 0, 5},\n                        {7, 8, 1} };\n\n    Tree puzzle = new Tree(toSolve);\n    System.out.println("Matriz de prueba: ");\n    puzzle.print();\n    System.out.println("T value is: "+puzzle.getTValue());\n    System.out.println("-------------------");\n    puzzle.solve();\n}'}),Object(d.jsx)("h3",{id:"practica3/video",children:"Performance"}),Object(d.jsx)("iframe",{src:"https://www.youtube.com/embed/SSJU7dyeEcs",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0}),Object(d.jsx)("h3",{id:"practica3/conclusions",children:"Conclusions"}),Object(d.jsx)("p",{children:"This practice left a lot of knowledge for each member of the team, this topic centered in the searching of the shortest path to achieve a goal, in this case by using trees allows the best comprehension of adaptative systems like troubleshooting by search. The way of the structure of this problem was so simple thanks to the work in team, the process to create a code that could solve a puzzle that is so difficult for a person made us work harder because it is a great achievement for each member to watch the resolution of a problem that by hand seems so bored or complex. For next upgrades it would be a good idea create a graphic interface user that allows the visualization of the movements history and gives to the user more control about the initial and the final state."}),Object(d.jsx)("h3",{id:"practica3/references",children:"References"}),Object(d.jsxs)("ol",{children:[Object(d.jsxs)("li",{children:["Great Learning Team. (2021, August 17). Best First Search Algorithm in AI | Concept, Implementation, Advantages, Disadvantages",Object(d.jsx)("a",{href:"https://www.mygreatlearning.com/blog/best-first-search-bfs/",children:"www.mygreatlearning.com"})]}),Object(d.jsxs)("li",{children:["Informed Search Algorithms in AI - Javatpoint. (n.d.).",Object(d.jsx)("a",{href:"https://www.javatpoint.com/ai-informed-search-algorithms",children:"www.javatpoint.com"})]})]})]})]})};var W=function(){return Object(d.jsx)(p,{children:"Work in progress..."})};var q=function(){return Object(d.jsx)(p,{children:"Work in progress..."})},z=function(){return Object(d.jsx)("div",{className:"App",children:Object(d.jsxs)(o.a,{children:[Object(d.jsx)(l,{}),Object(d.jsxs)(c.c,{children:[Object(d.jsx)(c.a,{path:"/practica1",component:y}),Object(d.jsx)(c.a,{path:"/practica2",component:I}),Object(d.jsx)(c.a,{path:"/practica3",component:G}),Object(d.jsx)(c.a,{path:"/practica4",component:W}),Object(d.jsx)(c.a,{path:"/pia",component:q}),Object(d.jsx)(c.a,{path:"/",component:y})]})]})})};r.a.render(Object(d.jsx)(s.a.StrictMode,{children:Object(d.jsx)(z,{})}),document.getElementById("root"))},33:function(e,t,a){},34:function(e,t,a){},41:function(e,t,a){},42:function(e,t,a){},43:function(e,t,a){},44:function(e,t,a){},45:function(e,t,a){}},[[265,1,2]]]);
//# sourceMappingURL=main.13c3eb57.chunk.js.map